<!DOCTYPE html>
<html lang="nl">
<head>
    <title>Plug and Play Demonstrator</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        h1, h2 {
            font-size: 40px;
        }
        .chart-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
        }
        canvas {
            width: 100% !important;
            height: 800px !important;
        }
    </style>
</head>
<body>

<h1>Grafieken Temperatuur en Vochtigheid</h1>

<div class="chart-grid">
    <canvas id="temperatureChart"></canvas>
    <canvas id="humidityChart"></canvas>
</div>

<h2>Downloads</h2>
<ul>
    <li><a href="/download/sensorbuitenmuur.csv"><button>Download sensorbuitenmuur CSV</button></a></li>
    <li><a href="/download/sensorbinnenmuur.csv"><button>Download sensorbinnenmuur CSV</button></a></li>
    <li><a href="/download/sensorhoek.csv"><button>Download sensorhoek CSV</button></a></li>
    <li><a href="/download/sensorvloer.csv"><button>Download sensorvloer CSV</button></a></li>
    <li><a href="/download/sensorraam.csv"><button>Download sensorraam CSV</button></a></li>
    <li><a href="/download/sensorruimte.csv"><button>Download sensorruimte CSV</button></a></li>
    <li><a href="/download/weerdata.csv"><button>Download windrichting CSV</button></a></li>
    <li><a href="/download/weer_speed.csv"><button>Download windsnelheid CSV</button></a></li>
</ul>

<h2>Alle CSV-bestanden in één ZIP</h2>
<a href="/download/all-csvs.zip">
    <button>Download Alle CSV's als ZIP</button>
</a>

<h2>Laatste foutmelding</h2>
<div style="border: 1px solid #cc0000; padding: 10px; background-color: #ffe6e6;">
    <strong>Bestand:</strong> <span id="error-source">{{ latest_error.source }}</span><br>
    <strong>Tijdstip:</strong> <span id="error-timestamp">{{ latest_error.timestamp }}</span><br>
    <strong>Temp en humidity:</strong> <span id="error-description">{{ latest_error.description }}</span>
</div>

<script>
    function movingAverage(data, windowSize) {
    const result = [];
    for (let i = 0; i <= data.length - windowSize; i++) {
        const window = data.slice(i, i + windowSize);
        const avg = window.reduce((sum, val) => sum + val, 0) / windowSize;
        result.push(avg);
    }
    return result;
    }

    
    function updateLatestError() {
        fetch('/latest-error')
            .then(response => response.json())
            .then(data => {
                document.getElementById('error-source').textContent = data.source;
                document.getElementById('error-timestamp').textContent = data.timestamp;
                document.getElementById('error-description').textContent = data.description;
            })
            .catch(error => console.error('Error fetching the latest error:', error));
    }

    setInterval(updateLatestError, 60000);

    
    const sensorFiles = [
        "sensorbuitenmuur",
        "sensorbinnenmuur",
        "sensorhoek",
        "sensorvloer",
        "sensorraam",
        "sensorruimte"
    ];

    const temperatureChartCtx = document.getElementById('temperatureChart').getContext('2d');
    const humidityChartCtx = document.getElementById('humidityChart').getContext('2d');

    const sensorColors = {
        sensorbuitenmuur: 'rgb(232, 200, 0)',
        sensorbinnenmuur: 'rgb(0, 255, 0)',
        sensorhoek: 'rgb(0, 0, 255)',
        sensorvloer: 'rgb(0, 0, 0)',
        sensorraam: 'rgb(125, 125, 125)',
        sensorruimte: 'rgb(125, 0, 255)'
    };

    let temperatureChart;
    let humidityChart;

    function loadAllSensorData() {
        const promises = sensorFiles.map(sensorId =>
            fetch(`/graph-data/${sensorId}.csv`)
                .then(response => response.json())
                .then(data => {
                    // Beperk tot de laatste 288 datapunten
                    const totalPoints = data.timestamps.length;
                    const startIndex = Math.max(0, totalPoints - 288);

                    return {
                        sensorId,
                        timestamps: data.timestamps.slice(startIndex),
                        temperatures: data.temperatures.slice(startIndex),
                        humidities: data.humidities.slice(startIndex)
                    };
                })
        );

        Promise.all(promises).then(sensorDataArray => {
            const timestamps = sensorDataArray[0].timestamps.slice(2, -2);


            const temperatureDatasets = sensorDataArray.map(sensor => {
                const smoothedTemps = movingAverage(sensor.temperatures, 21);
                const adjustedTimestamps = sensor.timestamps.slice(10, -10); // om lengte gelijk te maken
                return {
                    label: sensor.sensorId,
                    data: smoothedTemps,
                    borderColor: sensorColors[sensor.sensorId],
                    borderWidth: 2,
                    pointRadius: 0,
                    tension: 0.5,
                    cubicInterpolationMode: 'monotone',
                    fill: false
                };
            });

            const humidityDatasets = sensorDataArray.map(sensor => {
                const smoothedHumidities = movingAverage(sensor.humidities, 21);
                const adjustedTimestamps = sensor.timestamps.slice(10, -10);
                return {
                    label: sensor.sensorId,
                    data: smoothedHumidities,
                    borderColor: sensorColors[sensor.sensorId],
                    borderWidth: 2,
                    pointRadius: 0,
                    tension: 0.5,
                    cubicInterpolationMode: 'monotone',
                    fill: false
                };
            });


            if (temperatureChart) {
                temperatureChart.data.labels = timestamps;
                temperatureChart.data.datasets = temperatureDatasets;
                temperatureChart.update();
            } else {
                temperatureChart = new Chart(temperatureChartCtx, {
                    type: 'line',
                    data: {
                        labels: timestamps,
                        datasets: temperatureDatasets
                    },
                    options: chartOptions('Temperatuur (°C)')
                });
            }

            if (humidityChart) {
                humidityChart.data.labels = timestamps;
                humidityChart.data.datasets = humidityDatasets;
                humidityChart.update();
            } else {
                humidityChart = new Chart(humidityChartCtx, {
                    type: 'line',
                    data: {
                        labels: timestamps,
                        datasets: humidityDatasets
                    },
                    options: chartOptions('Luchtvochtigheid (%)')
                });
            }
        });
    }

    function chartOptions(titleText) {
    return {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
            tooltip: {
                enabled: true,
                bodyFont: { size: 20 }
            },
            title: {
                display: true,
                text: titleText,
                font: { size: 40 }
            },
            legend: {
                labels: {
                    font: { size: 32 },
                    generateLabels: function(chart) {
                        const datasets = chart.data.datasets;
                        return datasets.map((dataset, i) => ({
                            text: dataset.label,
                            fillStyle: dataset.borderColor || dataset.backgroundColor,
                            strokeStyle: dataset.borderColor || dataset.backgroundColor,
                            lineWidth: 0,
                            hidden: !chart.isDatasetVisible(i),
                            index: i
                        }));
                    }
                }
            }
        },
        scales: {
            x: {
                title: { display: false },
                ticks: {
                    callback: function(value, index, ticks) {
                        return index % 24 === 0 ? this.getLabelForValue(value) : '';
                    },
                    font: { size: 20 }
                }
            },
            y: {
                ticks: { font: { size: 20 } }
            }
        }
    };
}

    loadAllSensorData();
    setInterval(loadAllSensorData, 60000);
    
</script>

</body>
</html>
